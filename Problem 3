import numpy as np

# Problem 3:
rng = np.random.default_rng(seed=42)
NUM_KNAPSACKS = 100
NUM_ITEMS = 5000
NUM_DIMENSIONS = 100
VALUES = rng.integers(0, 1000, size=NUM_ITEMS)
WEIGHTS = rng.integers(0, 1000, size=(NUM_ITEMS, NUM_DIMENSIONS))
CONSTRAINTS = rng.integers(
    1000 * 10, 1000 * 2 * NUM_ITEMS // NUM_KNAPSACKS, size=(NUM_KNAPSACKS, NUM_DIMENSIONS)
)

import numpy as np
import random
from copy import deepcopy
from tqdm.auto import tqdm

# Probability for each tweak operation
P_REMOVE = 0.3
P_ADD = 0.3
P_SWAP = 0.4

def evaluate(solution):
    total_value = 0
    for item in range(len(solution)):
        sack = solution[item]
        if sack != -1:
            total_value += VALUES[item]
    return total_value

def tweak(solution, strength=0.1):
    new_sol = deepcopy(solution)

    while True:
        op_choice = random.random()

        # Remove an item
        if op_choice < P_REMOVE:
            assigned_items = [i for i, sack in enumerate(new_sol) if sack != -1]
            if assigned_items:
                item = random.choice(assigned_items)
                new_sol[item] = -1

        # Add an item
        elif op_choice < P_REMOVE + P_ADD:
            unassigned_items = [i for i, sack in enumerate(new_sol) if sack == -1]
            if unassigned_items:
                item = random.choice(unassigned_items)
                new_sol[item] = random.randint(0, NUM_KNAPSACKS - 1)

        # Swap items between knapsacks
        else:
            assigned_items = [i for i, sack in enumerate(new_sol) if sack != -1]
            if len(assigned_items) >= 2:
                i1, i2 = random.sample(assigned_items, 2)
                sack1, sack2 = new_sol[i1], new_sol[i2]
                new_sol[i1], new_sol[i2] = sack2, sack1

        # Repeat tweak with a given probability (strength)
        if random.random() >= strength:
            break

    # Feasibility correction
    loads = np.zeros((NUM_KNAPSACKS, NUM_DIMENSIONS), dtype=int)
    for i, sack in enumerate(new_sol):
        if sack != -1:
            loads[sack] += WEIGHTS[i]

    for k in range(NUM_KNAPSACKS):
        while np.any(loads[k] > CONSTRAINTS[k]):
            items_in_k = [i for i, s in enumerate(new_sol) if s == k]
            if not items_in_k:
                break
            densities = [(i, VALUES[i] / (np.sum(WEIGHTS[i]) + 1e-6)) for i in items_in_k]
            worst_item = min(densities, key=lambda x: x[1])[0]
            new_sol[worst_item] = -1
            loads[k] -= WEIGHTS[worst_item]

    return new_sol


# Generate an initial feasible solution
def build_feasible_solution()():
    solution = [-1] * NUM_ITEMS
    loads = np.zeros((NUM_KNAPSACKS, NUM_DIMENSIONS), dtype=int)
    
    # Compute density for each item
    densities = []
    for i in range(NUM_ITEMS):
        avg_weight = np.mean(WEIGHTS[i])
        density = VALUES[i] / (avg_weight + 1e-6)
        densities.append((i, density))

    densities.sort(key=lambda x: x[1], reverse=True)
    
    # Assign each item to the first knapsack that has enough capacity
    for item_idx, _ in densities:
        item_weight = WEIGHTS[item_idx]
        
        for k in range(NUM_KNAPSACKS):
            if np.all(loads[k] + item_weight <= CONSTRAINTS[k]):
                solution[item_idx] = k
                loads[k] += item_weight
                break
    
    return solution


print("Generating initial feasible solution...")
current_solution = build_feasible_solution()()

initial_value = evaluate(current_solution)
print(f"Initial solution: Value = {initial_value}")
current_value = initial_value

MAX_STEPS = 50000

best_solution = deepcopy(current_solution)
best_value = initial_value

# Compute theoretical maximum possible value
max_possible_value = np.sum(VALUES)
best_ratio = (best_value / max_possible_value) * 100

print(f"Theoretical maximum total value: {max_possible_value}\n")


pbar = tqdm(range(MAX_STEPS), desc="Hill Climbing", unit="step")

for step in pbar:
    new_solution = tweak(current_solution, strength=0.3)
    new_value = evaluate(new_solution)

    if new_value >= current_value:
        current_solution = new_solution
        current_value = new_value

        if current_value > best_value:
            best_solution = deepcopy(current_solution)
            best_value = current_value
            best_ratio = (best_value / max_possible_value) * 100

    pbar.set_postfix({
        "Best Value": f"{best_value}",
        "Ratio": f"{best_ratio:.2f}%"
    })

pbar.close()

# Output
#ratio_b = (best_value / max_possible_value) * 100
#print(f"\nBest solution found:")
#print(f"Value = {best_value}")
#print(f"Ratio = {ratio_b:.2f}% of theoretical maximum value")


#Generating initial feasible solution...
#Initial solution: Value = 1818128
#Theoretical maximum total value: 2490698

#Hill Climbing: 100%
# 50000/50000 [07:45<00:00, 72.64step/s, Best Value=1992320, Ratio=79.99%]

#Best solution found:
#Value = 1992320
#Ratio = 79.99% of theoretical maximum value
